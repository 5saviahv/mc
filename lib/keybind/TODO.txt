/*

== кеймапы работают как: ==

клавиша - название

название вполне может быть Event!


mc.hotkeys

[Группа]
 действие=клавиша


Это должно быть преобразовано в Event как:
 mcevent_add_cb ("Группа.действие", ...)

при этом спец. группа 'mc.*'(и дочерние) должны быть проигнорированы в файле привязок

главная группа [core]

Инициализируется по дефолту. остальные группы описывают дополнительные назначения клавиш.

Спец.случаи. Панель и командная строка.
[panel]
 - тут кейбиндинги панели.
[panel-commandline]
 - тут кейбиндинги комстроки.

признак того, что необходимо включить или выключить "panel-commandline.*" - не пустая или пустая комстрока.
При непустой комстроке делаем просто mckeybind_push ("panel-commandline"), а как только строка очищается - 
делаем mckeybind_pop();

То есть. выглядит всё так:
mckeybind_init("core"); // инициализируем некие базовые(одинаковые для всех) хоткеи.

switch (args)
 {
  case 'editor':
    mckeybind_push("editor");
  case 'viewer'
    mckeybind_push("viewer");
  default:
    mckeybind_push("panel");
 }
 ...
 if (cmd_active())
    mckeybind_push("panel-commandline");

 ...
  if (cmd_inactive())
    mckeybind_pop();


== КЕЙБИНДИНГИ ПО УМОЛЧАНИЮ ==
Должны содержать минимально необходимый для работы минимум. Если действие доступно через меню,
hardcoded-кейбиндинга быть не должно.

=== как инициальзировать ===
Ну... mckeybind_push("editor", g_hash_array *default(or NULL)) ?


== Хранение в памяти ==
храним в памяти в виде "хоткей" -> "event". Чтобы после чтения с клавы был быстрый доступ к mcevent_raise('action')

== Дубликаты хоткеев ==
наверное, надо предупреждать. что в конфиге есть конфликт...
[group]
action1 = ctrl-v
action2 = ctrl-v

в момент... гм. наверное. в момент mckeybind_push
ибо конфиг читаем целиком, но весь сразу не парсим...

== "Многоэтажные" хоткеи ==

=== Дубликаты: ===
action1 = ctrl-v
action2 = ctrl-v, w
Это ошибка. Выдать алерт.

=== Нормальная обработка ===
action1 = ctrl-v, q
action2 = ctrl-v, w
action3 = ctrl-v, e, 1
action4 = ctrl-v, e, 2


варианты использования.
mckeybind_push() должна добавить новые хоткеи к уже существующим (заменить существующие привязки клавиш).
mckeybind_pop() должна воостановить на предыдущее значение!

При этом должна быть возможность как бы временно "скрыть" существующие привязки. Для многоэтажных хоткеев.


//При парсинге видим многоэтажный хоткей и сразу создаём Event вида "mc.hotkey.<hotkey>".
// где <hotkey> - это <modificator>-<key> или просто <key>.
//mc_event_add_cb ("mc.hotkey.ctrl-v", );
нет. Надо предусмотреть временное замещение всех действующих хоткеев на только хоткеи "второго эшелона".
то есть, из примера надо после нажатия ctrl-v задейтвовать:
{
  q -> action1
  w -> action2
  e -> !!!!!!! (ещё раз очищаем хоткеи и ждём 1 или 2 !!!)
}
После всего этого возвращаемся в обычный режим работы.

делаем это созданием псевдогруппы привязок вида "mc.hotkey.<hotkey>".
где <hotkey> - это <modificator>-<key> или просто <key>.
затем привязываем "ctrl-v" к спецкейбиндингу:

ctrl-v -> "mc.hotkey.processMulti('ctrl-v')"

привязывать к именам хоткеев нужно структуру вида:
{
 char *action;
 char *param; /* для всех равен NULL, для многоэтажных равен названию группы хоткеев второго эшелона*/
}

при вызове этого Event начинаем искать группу хоткеев "mc.hotkey.ctrl-v"
находим и заменяем активные привязки на таблицу:

{
  q -> action1
  w -> action2
  e -> mc.hotkey.processMulti('ctrl-v,e')
}

NB: При парсинге файла привязок если встречаем мультихоткей, то ищем в списке групп - есть уже или нету.
"ctrl-v, e, 1" = ищем по группе "mc.hotkey.ctrl-v,e"
нашли - гуд. Добавляем.


== Порядок обработки файлов привязок ==
традиционно:
 1) комстрока
 2) переменная окружения
 3) конфиг в дом.каталоге
 4) конфиг в /etc/mc

*/




init
deinit

push
pop